This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
app/globals.css
app/layout.tsx
app/page.tsx
app/recipe/[id]/page.tsx
components/recipe-edit-form.tsx
components/recipe-form.tsx
components/recipe-list.tsx
drizzle.config.ts
lib/actions/recipes.ts
lib/db/drizzle.ts
lib/db/migrate.ts
lib/db/migrations/0000_opposite_guardian.sql
lib/db/migrations/meta/_journal.json
lib/db/migrations/meta/0000_snapshot.json
lib/db/queries.ts
lib/db/schema.ts
lib/db/seed.ts
lib/db/setup.ts
LICENSE
next.config.ts
package.json
postcss.config.mjs
prompt_plan.md
README.md
spec.md
todo.md
tsconfig.json

================================================================
Files
================================================================

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.vscode

================
File: app/globals.css
================
@import 'tailwindcss';

@theme {
  --font-family-sans: 'Geist', sans-serif;
}

================
File: app/layout.tsx
================
import type { Metadata } from 'next';
import { Geist_Mono } from 'next/font/google';
import './globals.css';

const geistMono = Geist_Mono({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Todo List',
  description: 'A simple todo list application',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={`${geistMono.className} bg-gray-900 text-gray-200`}>
        {children}
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
import { RecipeList } from "@/components/recipe-list";
import { RecipeForm } from "@/components/recipe-form";
import { Suspense } from "react";

// This will be replaced by 'use cache' soon
export const dynamic = "force-static";

export default function Home() {
  return (
    <div className="min-h-screen p-8 bg-gray-900">
      <main className="max-w-4xl mx-auto p-4">
        <h1 className="text-2xl font-bold mb-8">Mina Recept</h1>

        <div className="mb-8">
          <h2 className="text-xl font-semibold mb-4">Lägg till nytt recept</h2>
          <RecipeForm />
        </div>

        <div>
          <h2 className="text-xl font-semibold mb-4">Sparade recept</h2>
          <Suspense fallback={<div>Laddar recept...</div>}>
            <RecipeList />
          </Suspense>
        </div>
      </main>
    </div>
  );
}

================
File: app/recipe/[id]/page.tsx
================
import { EditRecipeForm } from "@/components/recipe-edit-form";
import {
  getRecipeById,
  updateRecipe,
  type Recipe,
} from "@/lib/actions/recipes";
import { notFound } from "next/navigation";

type Props = {
  params: {
    id: string;
  };
};

export default async function EditRecipePage({ params }: Props) {
  const recipe = await getRecipeById(parseInt(params.id));

  if (!recipe) {
    notFound();
  }

  const handleUpdate = async (
    updatedRecipe: Partial<Recipe> & { id: number }
  ) => {
    "use server";
    await updateRecipe(
      updatedRecipe.id,
      updatedRecipe.title,
      updatedRecipe.url,
      updatedRecipe.labels ?? []
    );
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Redigera recept</h1>
      <EditRecipeForm recipe={recipe} onSubmit={handleUpdate} />
    </div>
  );
}

================
File: components/recipe-edit-form.tsx
================
"use client";

import { useState, FormEvent } from "react";
import { useRouter } from "next/navigation";
import type { Recipe } from "@/lib/actions/recipes";

type EditRecipeFormProps = {
  recipe: Recipe;
  onSubmit: (recipe: Partial<Recipe> & { id: number }) => Promise<void>;
};

export function EditRecipeForm({ recipe, onSubmit }: EditRecipeFormProps) {
  const router = useRouter();
  const [title, setTitle] = useState(recipe.title);
  const [url, setUrl] = useState(recipe.url);
  const [labels, setLabels] = useState<string[]>(recipe.labels ?? []);
  const [newLabel, setNewLabel] = useState("");
  const [error, setError] = useState("");

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError("");

    try {
      await onSubmit({
        id: recipe.id,
        title,
        url,
        labels,
      });
      router.push("/");
      router.refresh();
    } catch (err) {
      setError("Ett fel uppstod vid uppdatering av receptet");
    }
  };

  const addLabel = () => {
    if (newLabel.trim() && !labels.includes(newLabel.trim())) {
      setLabels([...labels, newLabel.trim()]);
      setNewLabel("");
    }
  };

  const removeLabel = (labelToRemove: string) => {
    setLabels(labels.filter((label) => label !== labelToRemove));
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-700">Titel</label>
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          required
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700">URL</label>
        <input
          type="url"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          required
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700">
          Etiketter
        </label>
        <div className="flex gap-2 flex-wrap mt-2">
          {labels.map((label) => (
            <span
              key={label}
              className="bg-blue-100 px-2 py-1 rounded-md flex items-center"
            >
              {label}
              <button
                type="button"
                onClick={() => removeLabel(label)}
                className="ml-2 text-red-500"
              >
                ×
              </button>
            </span>
          ))}
        </div>
        <div className="flex mt-2">
          <input
            type="text"
            value={newLabel}
            onChange={(e) => setNewLabel(e.target.value)}
            className="flex-1 rounded-l-md border border-gray-300 px-3 py-2"
            placeholder="Lägg till etikett"
          />
          <button
            type="button"
            onClick={addLabel}
            className="bg-blue-500 text-white px-4 py-2 rounded-r-md"
          >
            +
          </button>
        </div>
      </div>

      {error && <p className="text-red-500">{error}</p>}

      <button
        type="submit"
        className="bg-green-500 text-white px-4 py-2 rounded-md"
      >
        Spara ändringar
      </button>
    </form>
  );
}

================
File: components/recipe-form.tsx
================
'use client';

import { createRecipe } from '@/lib/actions/recipes';
import { useState } from 'react';

export function RecipeForm() {
  const [title, setTitle] = useState('');
  const [url, setUrl] = useState('');
  const [labels, setLabels] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const labelArray = labels.split(',').map(l => l.trim()).filter(l => l !== '');
    
    try {
      await createRecipe(title, url, labelArray);
      setTitle('');
      setUrl('');
      setLabels('');
    } catch (error) {
      console.error('Failed to create recipe:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="title" className="block">Titel</label>
        <input
          type="text"
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
          className="w-full border p-2 rounded"
        />
      </div>

      <div>
        <label htmlFor="url" className="block">URL</label>
        <input
          type="url"
          id="url"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          required
          className="w-full border p-2 rounded"
        />
      </div>

      <div>
        <label htmlFor="labels" className="block">Etiketter (kommaseparerade)</label>
        <input
          type="text"
          id="labels"
          value={labels}
          onChange={(e) => setLabels(e.target.value)}
          className="w-full border p-2 rounded"
          placeholder="t.ex. middag, vegetariskt, snabbt"
        />
      </div>

      <button 
        type="submit"
        className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
      >
        Lägg till recept
      </button>
    </form>
  );
}

================
File: components/recipe-list.tsx
================
import { getRecipes } from '@/lib/actions/recipes';

export async function RecipeList() {
  const recipes = await getRecipes();

  if (recipes.length === 0) {
    return <p className="text-gray-500 italic">Inga recept än...</p>;
  }

  return (
    <div className="space-y-4">
      {recipes.map((recipe) => (
        <div key={recipe.id} className="border p-4 rounded-lg">
          <h2 className="font-bold">{recipe.title}</h2>
          <a href={recipe.url} className="text-blue-500 hover:underline" target="_blank" rel="noopener noreferrer">
            {recipe.url}
          </a>
          <div className="mt-2 flex gap-2">
            {recipe.labels?.map((label) => (
              <span key={label} className="bg-gray-100 px-2 py-1 rounded-full text-sm">
                {label}
              </span>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}

================
File: drizzle.config.ts
================
import type { Config } from 'drizzle-kit';

export default {
  schema: './lib/db/schema.ts',
  out: './lib/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.POSTGRES_URL!,
  },
} satisfies Config;

================
File: lib/actions/recipes.ts
================
"use server";

import { revalidatePath } from "next/cache";
import { eq } from "drizzle-orm";
import { db } from "@/lib/db/drizzle";
import { recipes } from "@/lib/db/schema";

export type Recipe = typeof recipes.$inferSelect;

export async function createRecipe(
  title: string,
  url: string,
  labels: string[]
): Promise<Recipe> {
  const [newRecipe] = await db
    .insert(recipes)
    .values({
      title,
      url,
      labels,
      dateAdded: new Date(),
    })
    .returning();

  revalidatePath("/");

  return newRecipe;
}

export async function getRecipes(): Promise<Recipe[]> {
  return await db.select().from(recipes);
}

export async function getRecipeById(id: number): Promise<Recipe | null> {
  const [recipe] = await db
    .select()
    .from(recipes)
    .where(eq(recipes.id, id))
    .limit(1);

  return recipe ?? null;
}

export async function updateRecipe(
  id: number,
  title?: string,
  url?: string,
  labels?: string[]
): Promise<Recipe | null> {
  const updates: Partial<Recipe> = {};
  if (title !== undefined) updates.title = title;
  if (url !== undefined) updates.url = url;
  if (labels !== undefined) updates.labels = labels;

  const [updated] = await db
    .update(recipes)
    .set(updates)
    .where(eq(recipes.id, id))
    .returning();

  revalidatePath("/");

  return updated ?? null;
}

export async function deleteRecipe(id: number): Promise<boolean> {
  const [deleted] = await db
    .delete(recipes)
    .where(eq(recipes.id, id))
    .returning();

  revalidatePath("/");

  return deleted !== undefined;
}

================
File: lib/db/drizzle.ts
================
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';
import dotenv from 'dotenv';

dotenv.config();

if (!process.env.POSTGRES_URL) {
  throw new Error('POSTGRES_URL environment variable is not set');
}

export const client = postgres(process.env.POSTGRES_URL);
export const db = drizzle(client, { schema });

================
File: lib/db/migrate.ts
================
import dotenv from 'dotenv';
import path from 'path';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import { client, db } from './drizzle';

dotenv.config();

async function main() {
  await migrate(db, {
    migrationsFolder: path.join(process.cwd(), '/lib/db/migrations'),
  });
  console.log(`Migrations complete`);
  await client.end();
}

main();

================
File: lib/db/migrations/0000_opposite_guardian.sql
================
CREATE TABLE IF NOT EXISTS "recipes" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" varchar(255) NOT NULL,
	"url" varchar(1024) NOT NULL,
	"labels" text[],
	"date_added" timestamp with time zone DEFAULT now() NOT NULL
);

================
File: lib/db/migrations/meta/_journal.json
================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1740380290399,
      "tag": "0000_opposite_guardian",
      "breakpoints": true
    }
  ]
}

================
File: lib/db/migrations/meta/0000_snapshot.json
================
{
  "id": "545ab023-a36a-407e-8da3-9288e79d557c",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.recipes": {
      "name": "recipes",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "url": {
          "name": "url",
          "type": "varchar(1024)",
          "primaryKey": false,
          "notNull": true
        },
        "labels": {
          "name": "labels",
          "type": "text[]",
          "primaryKey": false,
          "notNull": false
        },
        "date_added": {
          "name": "date_added",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: lib/db/queries.ts
================
import { db } from './drizzle';
import { InferSelectModel } from 'drizzle-orm';

================
File: lib/db/schema.ts
================
import { pgTable, serial, varchar, timestamp, text } from 'drizzle-orm/pg-core';

export const recipes = pgTable('recipes', {
  id: serial('id').primaryKey(),
  title: varchar('title', { length: 255 }).notNull(),
  url: varchar('url', { length: 1024 }).notNull(),
  labels: text('labels').array(),
  dateAdded: timestamp('date_added', { withTimezone: true }).defaultNow().notNull()
});

================
File: lib/db/seed.ts
================
import { db } from './drizzle';
import { seed } from 'drizzle-seed';

================
File: lib/db/setup.ts
================
import { exec } from 'node:child_process';
import { promises as fs } from 'node:fs';
import { promisify } from 'node:util';
import readline from 'node:readline';
import path from 'node:path';

const execAsync = promisify(exec);

function question(query: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) =>
    rl.question(query, (ans) => {
      rl.close();
      resolve(ans);
    })
  );
}

async function getPostgresURL(): Promise<string> {
  console.log('Step 1: Setting up Postgres');
  const dbChoice = await question(
    'Do you want to use a local Postgres instance with Docker (L) or a remote Postgres instance (R)? (L/R): '
  );

  if (dbChoice.toLowerCase() === 'l') {
    console.log('Setting up local Postgres instance with Docker...');
    await setupLocalPostgres();
    return 'postgres://postgres:postgres@localhost:54322/postgres';
  } else {
    console.log(
      'You can find Postgres databases at: https://vercel.com/marketplace?category=databases'
    );
    return await question('Enter your POSTGRES_URL: ');
  }
}

async function setupLocalPostgres() {
  console.log('Checking if Docker is installed...');
  try {
    await execAsync('docker --version');
    console.log('Docker is installed.');
  } catch (error) {
    console.error(
      'Docker is not installed. Please install Docker and try again.'
    );
    console.log(
      'To install Docker, visit: https://docs.docker.com/get-docker/'
    );
    process.exit(1);
  }

  console.log('Creating docker-compose.yml file...');
  const dockerComposeContent = `
services:
  postgres:
    image: postgres:16.4-alpine
    container_name: music_player_postgres
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "54322:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
`;

  await fs.writeFile(
    path.join(process.cwd(), 'docker-compose.yml'),
    dockerComposeContent
  );
  console.log('docker-compose.yml file created.');

  console.log('Starting Docker container with `docker compose up -d`...');
  try {
    await execAsync('docker compose up -d');
    console.log('Docker container started successfully.');
  } catch (error) {
    console.error(
      'Failed to start Docker container. Please check your Docker installation and try again.'
    );
    process.exit(1);
  }
}

async function writeEnvFile(envVars: Record<string, string>) {
  console.log('Step 3: Writing environment variables to .env');
  const envContent = Object.entries(envVars)
    .map(([key, value]) => `${key}=${value}`)
    .join('\n');

  await fs.writeFile(path.join(process.cwd(), '.env'), envContent);
  console.log('.env file created with the necessary variables.');
}

async function main() {
  const POSTGRES_URL = await getPostgresURL();

  await writeEnvFile({
    POSTGRES_URL,
  });

  console.log('🎉 Setup completed successfully!');
}

main().catch(console.error);

================
File: LICENSE
================
The MIT License (MIT)

Copyright (c) 2024 Vercel, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: next.config.ts
================
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {};

export default nextConfig;

================
File: package.json
================
{
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "db:setup": "npx tsx lib/db/setup.ts",
    "db:seed": "npx tsx lib/db/seed.ts",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "npx tsx lib/db/migrate.ts",
    "db:studio": "drizzle-kit studio"
  },
  "dependencies": {
    "@tailwindcss/postcss": "4.0.0-beta.4",
    "@types/node": "^22.10.1",
    "@types/react": "npm:types-react@19.0.0-rc.1",
    "@types/react-dom": "npm:types-react-dom@19.0.0-rc.1",
    "dotenv": "^16.4.7",
    "drizzle-kit": "^0.28.1",
    "drizzle-orm": "^0.36.4",
    "drizzle-seed": "^0.1.2",
    "lucide-react": "^0.465.0",
    "next": "15.0.4-canary.36",
    "postgres": "^3.4.5",
    "react": "19.0.0-rc-2d16326d-20240930",
    "react-dom": "19.0.0-rc-2d16326d-20240930",
    "tailwindcss": "4.0.0-beta.4",
    "typescript": "^5.7.2",
    "zod": "^3.23.8"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};

================
File: prompt_plan.md
================
# Prompt 1: Initialize Next.js, TypeScript, TailwindCSS

Please generate a shell script that:
1. Creates a new Next.js application with TypeScript using "create-next-app".
2. Installs and configures TailwindCSS for styling.
3. Creates a basic "page.tsx" with a minimal Tailwind layout to confirm everything is working.
Make sure there are comments explaining each step and how to run the project afterwards.

# Prompt 2: Configure Drizzle & PostgreSQL

We now have a Next.js + Tailwind project. We want to:

1. Install Drizzle ORM and PostgreSQL dependency.
2. Create a `db/connection.ts` that initializes Drizzle with a Postgres connection, pulling the connection string from environment variables.
3. Create a `db/schema.ts` with a `recipes` table that has:
   - id (primary key, serial),
   - title (string),
   - url (string),
   - labels (text array),
   - date_added (timestamp with time zone).
4. Generate a migration script and run it.

Include example environment variables in a `.env.example` file (like `DATABASE_URL`). Provide instructions on how to run the migration.

# Prompt 3: Create Server Actions for CRUD

We have a Drizzle setup with a `recipes` table. Now, let's create server actions in Next.js. Specifically, we want a file `server/actions/recipes.ts` with the following exported functions:

1. `createRecipe(title: string, url: string, labels: string[]): Promise<Recipe>`
2. `getRecipes(): Promise<Recipe[]>`
3. `getRecipeById(id: number): Promise<Recipe | null>`
4. `updateRecipe(id: number, title?: string, url?: string, labels?: string[]): Promise<Recipe | null>`
5. `deleteRecipe(id: number): Promise<boolean>`

Return type `Recipe` should match the table columns. Use Drizzle to perform the queries. Show how we might test them temporarily, for example with a test route in `app/api/test/route.ts`.

# Prompt 4: Front-End: Add & List Recipes

Now let's create front-end components in Next.js to add and list recipes:

1. In `app/page.tsx`, create a `RecipeList` component that fetches and displays all recipes. 
2. Create a `RecipeForm` component that has fields (title, url, labels) and a submit button to call `createRecipe`.
3. After a new recipe is created, the list should re-fetch or update automatically.
4. Show how to integrate `RecipeForm` and `RecipeList` in `page.tsx`.

Ensure we're following React best practices with server actions or client components as needed. Provide complete files for `app/page.tsx` and any additional files.

# Prompt 5: Edit & Label Management

Now we want to implement editing a recipe, including label management:

1. Create a new page at `app/recipe/[id]/page.tsx` that:
   - Fetches the recipe by ID using `getRecipeById`.
   - Shows an edit form with pre-filled fields (title, url, labels).
2. On submit, calls `updateRecipe` to persist changes.
3. Ensure we can add and remove labels (like a small UI control).
4. Provide TypeScript definitions and show how we navigate to `/recipe/[id]` from the main page.

Please generate the complete code for `app/recipe/[id]/page.tsx` and any utility component needed (like a label editor).

# Prompt 6: Search & Sort

We now want to add search and sorting functionality:

1. Add a search bar to `page.tsx` that filters recipes by title or label (case-insensitive, partial matches).
2. Add sort controls (by date and by label, ascending or descending).
3. Decide if search/sort are done client-side or via a server action (explain which approach you're taking and why).
4. Generate the updated `page.tsx` code, explaining how state or server actions handle the results.

We already have a list of recipes and a create form, so update that existing code rather than rewriting from scratch.

# Prompt 7: Share Links

We want each recipe to have a shareable URL that doesn't require authentication to edit:

1. Add a `slug` column to the `recipes` table (unique, not null).
2. Update creation logic to generate a unique slug (for example, `nanoid` or some slug library).
3. Display a "Share" button that copies the link `/recipe/[slug]`.
4. Create a new page `app/recipe/[slug]/page.tsx` that loads a recipe via `slug` and shows the same edit form.

Include a database migration for the slug column. Show how you ensure uniqueness. Provide the updated code.

# Prompt 8: Styling & Final Polish

Finally, let's apply TailwindCSS and add inline error messages in Swedish:

1. Update all existing pages (`app/page.tsx`, `app/recipe/[id]/page.tsx`, `app/recipe/[slug]/page.tsx`) to have playful Tailwind styling.
2. For error handling (e.g., if an update fails), display inline error messages in Swedish. For example, "Ett fel uppstod vid uppdatering."
3. Ensure all field labels, placeholders, and button text are in Swedish.
4. Generate the final code for all updated files, with a brief explanation of the design approach.

================
File: README.md
================
# Next.js and Postgres Starter Template

## Tech Stack

- **Framework**: [Next.js](https://nextjs.org/)
- **Database**: [Postgres](https://www.postgresql.org/)
- **ORM**: [Drizzle](https://orm.drizzle.team/)

## Getting Started

```bash
git clone https://github.com/vercel/postgres-next-starter
cd postgres-next-starter
pnpm install
```

## Running Locally

Use the included setup script to create your `.env` file:

```bash
pnpm db:setup
```

Then, run the database migrations and seed the database:

```bash
pnpm db:generate
pnpm db:migrate
pnpm db:seed
```

Finally, run the Next.js development server:

```bash
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) in your browser to see the app in action.

================
File: spec.md
================
Sure! Here is a comprehensive, developer-ready specification based on our discussions:

---

## Recipe Organizer Web Application Specification

### Overview

A web application that allows users to save URLs for recipes and add custom labels to each entry. Users can search, sort, and share recipes with unique URLs. The application is open to all users without authentication.

### Core Features

1. **Search Functionality:**

   - Search recipes by label and title.
   - Support partial matches and case-insensitive searches.

2. **Sorting Functionality:**

   - Sort recipes by label and date.
   - Support ascending and descending order for both labels and dates.

3. **Sharing Functionality:**
   - Share entries with a unique URL.
   - Allow all users to edit entries via the shared URL.

### User Interface

1. **Main Page:**

   - Combine adding recipes and viewing/searching recipes on a single page.
   - Playful design, but not too crazy.

2. **Edit Page:**

   - Separate page for editing recipes.

3. **Label Management:**
   - Users can create, edit, and delete labels.
   - Manage labels in a modal.

### Data Model

1. **Recipe Entry:**
   - Title (string)
   - URL (string)
   - Labels (array of strings)
   - Date Added (timestamp)

### Error Handling

1. **Notifications:**
   - Display inline error messages for error handling.
   - No notifications for successful operations (visual changes will indicate success).

### Performance

- No specific performance requirements due to the private and simple nature of the app.

### Accessibility and Internationalization

- The app should be in swedish.

### Architecture Choices

1. **Front-End:**

   - Framework: React & TailwindCSS.
   - Design: Playful, user-friendly interface.

2. **Back-End:**

   - Framework: Next.js
   - Data fetching: React Server Components 
   - Data updating: React Server Actions

3. **Database:**
   - Type: A PostgreSQL database with Drizzle ORM.

### Error Handling Strategies

1. **Client-Side:**

   - Validate user inputs (e.g., URL format, non-empty title).
   - Display inline error messages for invalid inputs or failed operations.

2. **Server-Side:**
   - Handle errors gracefully and return appropriate HTTP status codes.
   - Log errors for debugging and monitoring purposes.

### Deployment and Hosting

- Already provided and ready for use.

================
File: todo.md
================
# TODO: Recipe Organizer Web Application

This document serves as a comprehensive checklist to guide you step-by-step through the project, from initial setup to final polish. Check off each task as you complete it.

---

## Chunk 1: Project Setup

- [x] **Create Next.js App**
  - [x] Run `npx create-next-app@latest --typescript` to bootstrap the project.
  - [x] Verify the newly created project can run with `npm run dev` or `yarn dev`.

- [x] **Add TailwindCSS**
  - [x] Install Tailwind: `npm install -D tailwindcss postcss autoprefixer`
  - [x] Initialize Tailwind: `npx tailwindcss init -p`
  - [x] Configure `tailwind.config.js` to look at your project files.
  - [x] Import Tailwind styles in `globals.css`.
  - [x] Confirm Tailwind classes work (e.g., add a simple class in a page component).

- [x] **Project Verification**
  - [x] Open the local development URL and confirm the basic Next.js page loads.
  - [x] Confirm you can see Tailwind styling.

---

## Chunk 2: Database & Drizzle ORM

- [x] **Install Drizzle + PostgreSQL**
  - [x] `npm install drizzle-orm pg`
  - [x] Set up `.env` or `.env.local` with your `DATABASE_URL`.

- [x] **Drizzle Configuration**
  - [x] Create a file (e.g., `db/connection.ts`) to initialize Drizzle with Postgres.
  - [x] Ensure it reads the connection string from environment variables.

- [X] **Define Schema**
  - [X] In `db/schema.ts`, define a `recipes` table with:
    - `id` (serial primary key)
    - `title` (string)
    - `url` (string)
    - `labels` (text array)
    - `date_added` (timestamp)
  - [X] Export the schema objects (e.g. `recipes`).

- [X] **Migrations**
  - [X] Use Drizzle Kit (or your chosen migration tool) to generate a migration script.
  - [X] Run the migration to create the table in the database.
  - [X] Verify the table creation in your DB (e.g., via `psql` or a DB client).

---

## Chunk 3: Server Actions (CRUD)

- [x] **Set Up Directory**
  - [x] Create `server/actions/recipes.ts` (or a similar naming convention).

- [x] **Implement Create Action**
  - [x] Write a `createRecipe` function that inserts a new record into the `recipes` table.
  - [x] Return the newly created recipe object.

- [x] **Implement Read Actions**
  - [x] `getRecipes`: Fetch all recipes from the DB.
  - [x] `getRecipeById`: Fetch a single recipe by its `id`.

- [x] **Implement Update Action**
  - [x] `updateRecipe`: Given an `id`, update provided fields (`title`, `url`, `labels`).

- [x] **Implement Delete Action**
  - [x] `deleteRecipe`: Delete a recipe by `id`.

- [x] **Test in a Route**
  - [x] Create a temporary test route (e.g., `app/api/test/route.ts`) to confirm these actions work.
  - [x] Make sample API calls (e.g., using Postman or fetch) to verify functionality.

---

## Chunk 4: Front-End: Add & List Recipes

- [x] **Create `RecipeList` Component**
  - [x] Renders a list of existing recipes.
  - [x] Displays relevant recipe info (title, URL, labels, etc.).

- [x] **Create `RecipeForm` Component**
  - [x] Inputs: `title`, `url`, `labels` (simple comma-separated or a small labels UI).
  - [x] On submit, calls `createRecipe`.

- [x] **Integrate in Main Page (`app/page.tsx`)**
  - [x] Import and render both `RecipeList` and `RecipeForm`.
  - [x] Confirm that after submission, the list updates to show the new recipe (re-fetch or mutate client state).

- [x] **Visual Check**
  - [x] Load the page, add a new recipe, ensure it appears in the list.

---

## Chunk 5: Editing & Label Management

- [x] **Create Edit Page**
  - [x] In `app/recipe/[id]/page.tsx`, fetch the recipe by ID (`getRecipeById`).
  - [x] Prefill the form with the existing recipe data.

- [x] **Label Editing**
  - [x] Allow adding labels (typing a new label).
  - [x] Allow removing labels (e.g., via a small "x" button next to each label).
  - [x] Ensure they update via the `updateRecipe` action.

- [ ] **Navigation**
  - [ ] From the main page's recipe list, create a link/button to `/recipe/[id]`.
  - [ ] Confirm you can navigate, edit the recipe, and changes persist to the DB.

---

## Chunk 6: Search & Sort

- [ ] **Search Implementation**
  - [ ] Add a search bar to `app/page.tsx`.
  - [ ] Decide on client-side filtering (fetch all, filter in-memory) or server-side:
    - [ ] If client-side, maintain local state and filter array data.
    - [ ] If server-side, pass search terms to a server action to fetch filtered results.
  - [ ] Ensure partial matches and case-insensitive logic.

- [ ] **Sorting**
  - [ ] Provide controls for sorting by:
    - [ ] Date (asc/desc)
    - [ ] Label (asc/desc)
  - [ ] Update the recipe list accordingly.

- [ ] **Validation**
  - [ ] Confirm searching by partial label or title works.
  - [ ] Confirm sorting changes the order appropriately.

---

## Chunk 7: Share Links

- [ ] **Add `slug` Column**
  - [ ] Update `recipes` schema to include `slug` (unique, not null).
  - [ ] Generate a new migration, run it.

- [ ] **Generate Slugs**
  - [ ] Use a library like `nanoid` (or a custom function) in `createRecipe` to set `slug`.
  - [ ] Ensure uniqueness (either by library or checking DB collisions).

- [ ] **Shareable Route**
  - [ ] Create `app/recipe/[slug]/page.tsx`.
  - [ ] Fetch recipe by slug, not by ID.
  - [ ] Show same editing form as the ID route.

- [ ] **Test**
  - [ ] Confirm that sharing `/recipe/[slug]` works the same as `[id]` route for reading and editing.

---

## Chunk 8: Styling & Final Polish

- [ ] **Apply TailwindCSS**
  - [ ] Use a playful aesthetic (e.g., bright colors, rounded corners, etc.).
  - [ ] Refine the layout in `page.tsx`, `RecipeForm`, `RecipeList`, and so forth.

- [ ] **Inline Error Messages**
  - [ ] For create/update failures, show an error message (in Swedish).
  - [ ] For required fields (title, URL), show inline validation errors.

- [ ] **Swedish Localization**
  - [ ] Replace all placeholders in the UI with Swedish labels (e.g., "Titel", "Lägg till recept", etc.).
  - [ ] Error messages (e.g., "Ett fel uppstod vid uppdatering.").

- [ ] **Final Verification**
  - [ ] Navigate through the entire app (create, edit, search, share).
  - [ ] Confirm no broken links, no console errors.
  - [ ] Confirm the database reflects your changes.
  - [ ] Celebrate!

---

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}



================================================================
End of Codebase
================================================================
